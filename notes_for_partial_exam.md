# **Conversions**

## explained examples: 

### _Convert to hexadecimal_
    - from b2 
    we group the bits in packs of 4 and evaluate it in base 10, then translate it to b16 
        10100011b -> 1010 0011b -> A3h
        10110111b -> 1011 0111b -> B7h
    
    - from b8 
        8 is 2^3 -> we write each digit in 3 binary digits 
        => 17o -> 001111b -> 0000 1111b -> 0Fh 

### _Add the following numbers_
    a. 11001111b + 10110111b
    11001111b+
    10110111b 
    ---------
    110000110b   

    b. 0AFh + 15h
    AFh+
    15h
    ---
    C4h 
### _Convert -808(d) on 16 bits_
    808 / 16 = 50 r 8
    50 / 16 = 3 r 2 
    3 / 16 = 0 r 3  
    => 808 = 328h = 0000 0011 0010 1000b 
    we apply the 2's complement algorithm => 1111 1100 1101 1000b 
    this is the representation on 16 bits 

## exercises: 
### 1. _Compute_
    ~ 28h + 0F6h 
    28h+
    F6h 
    --- 
    11Eh 

    ~ 1A3h - 368h -> since 368h is bigger we subtract in the inverse order 
    368h - 
    1A3h 
    --- 
    1C5h => the answer is -1C5h

    ~ 0C33h - 0AF5h 
    C33h
    AF5h 
    ----
    13Eh
    
    ~ 144 + 1DFh -> we convert 144 to base 16 and then perform the addition 
    144 / 16 = 9 r 0
    9 / 16 = 0 r 9
    => 144 = 90h
     90h + 
    1DFh
    ----
    26Fh

    ~ 15 = Fh 

    ~ -176(d) = ... (h) = ...(b) on 16 bits 
    176 / 16 = 11 r 0
    11 / 16 = 0 r 11 
    => 176 = B0h = 0000 0000 1011 0000 b on 16 bits 
    => -176 = 1111 1111 0101 0000b

    ~ -80(d) = ... (h) =  ... (b) on 32 bits
    80 / 16 = 5 r 0 
    5 / 16 = 0 r 5 
    => 80 = 50h = 0000 0000 0000 0000 0000 0000 0101 0000b 
    => -80 = 1111 1111 1111 1111 1111 1111 1111 1011 0000b

### 2. _The value of 00100111b is:_
    00100111b = 0010 0111b = 27h => a.

### 3._The value of 0110_0011b is:_ 
    We can write it in base 16: 63h 
    For the decimal form we need to cover 2 interpretations : signed and unsigned.
    unsigned => 6 * 16 + 3 = 99 
    signed => - (256 - 99) = -157 


# **Variables and Memory Layout**
### _1. What is the memory representation for?_
    a db 11_22h
    b dw 1234h 
    c dd 11_22h
    d dd 11_22_33_44_55h
    e dw 11_22_34_45_56h 

When defining a variable, it will store in memory the number of bytes it is instructed to (db, dw, dd). If the number given exceeds this number of bytes, the last will be taken into account and the others discarded. 

Also it should be noted that variables are stored using the "little endian" method, meaning that bytes are stored in reverse order. 

So the memory configuration will be:
22 34 12 22 11 00 00 55 44 33 22 56 45 

### _2. How will the data be represented in memory?_
    a dd 125 
    b db 2
    c db 1,2,3,4
    d db '1234'
    e db '1,2,3,4'
    f db '1',',','2'
    g dw 'a' 

a dd 125 ->   
125 / 16 = 7 r 13  
7 / 16 = 0 r 7 => 125 = 7Dh  
doubleword => 7D 00 00 00 

b db 2 -> 02   
c db 1,2,3,4 -> 01 02 03 04  
d db '1234' -> 31 32 33 34 (the ascii code of '1' is 31 in hexadecimal notation)  
e db '1,2,3,4' -> 31 2C 32 2C 33 2C 34 (the ascii code of ',' is 2C in hexadecimal notation)
f db '1',',','2' -> 31 2C 32  
g dw 'a' -> 61 00  ('a' = 61h)

### _3. What will be stored in registries after running each instruction considering the following variable definition?_ 
    a db 11_22h 
    b dw 1234h 
    c db 0Ah 
    d dd 11_22h 
    mov al, [a];
    mov al, [b];
    mov ax, [a];
    mov eax, [b];
    mov ax, [a+1];
    mov bx, [c-2];
First we need the memory layout for the last two operations 
Memory layout: 22 34 12 0A 22 11 00 00h   
a points to the first 22, b points to 34, c points to 0A, and d points to the last 22  
the first three instructions are useless since the fourth one will write over the register   
mov eax, [b] => eax : 22 0A 12 34h  
mov ax, [a+1] => ax : 12 34h, so eax remains unchanged 
mov bx, [c-2] => bx: 12 34h


### _4. Are the following definitions equivalent (in terms of value and type) ?_ 
a) 
```
    b0 bd 256
    b1 dd 100h
```
No! The type does not match!

b) 
```
    b2 db 1203h 
    b3 db 3
```

Yes! The type matches and both values are 03h

### _5. Do the instructions generate the same result?_
    v db 4
    mov ax, 4
    mov ax, v
Since v is not dereferenced (with []), in the second variation we attribute ax the value of the memory address of v instead of the value at that location, obtaining a different result.

### _6. Do the instructions generate the same result?_
    v db 4
    x db 5
    y db 66h
    z dw 11_22h
    mov ax, 4
    mov eax, dword[v]
Memory layout: 04 05 66 22 11   
with the first instruction we get eax as: xx xx 00 04   
and with the second: 22 66 05 04  
so no, the instructions do not generate the same result.

### _7. What is the result generated by the instructions:_
    Mov al, Aah
    Mov ax, Aah

Syntax error!!! For the assembler to recognize Aah as a hexadecimal number, we need to add a 0 in front.

### _8. How many bytes will be reserved in the memory?_ 
    R resb 4
    a resw 2
    c resd 3 
    d resq 4
    e rest 1

Answer: 4 + 2 * 2 + 3 * 4 + 4 * 8 + 1 * 10 = 62 bytes

### _9. What values will be in the BX register and in variable c after running the following code?_ 
    a db 22h
    b db 22h 
    c dw 2h
    d dw 10h 

    mov ax, [a]
    mov bx, 4
    add bx, ax 
    mov ax, [b+1]
    add ax, [c+1]
    mov [c], ax

Memory layout: 22 22 02 00 10 00   
mov ax, [a] -> ax : 22 22h   
mov bx, 4 -> bx: 00 04h  
add bx, ax -> bx: 22 26h
mov ax, [b+1] -> ax: 00 02 
add ax, [c+1] -> ax: 00 02 + 10 00 = 10 02h
mov [c], ax -> c = 10 02h

### _10. What value will be in the AX register after running the following code, if variable a is a word, b,c and d are bytes and a=5, b=9, c=4, d=3?_ 
    mov ax, [a]
    add ax, 20 
    mov bx, [b] 
    mov bh, 0
    mov [b], bx 
    add bx, [c] 
    add ax, bx 

memory layout: 05 00 09 04 03
mov ax, [a] -> ax: 00 05h    
add ax, 20 -> ax: 00 19h   
mov bx, [b]  -> bx: 04 09    
mov bh, 0 -> bx: 00 09  
mov [b], bx -> 05 00 09 00 03  
add bx, [c] -> bx: 03 09  
add ax, bx -> ax: 03 22h

### _11. Which of the following variable definitions are correct? (H or X for hexadecimal, D or T for decimal, Q or O for octal and B and Y for binary)?_ 
    a0 db 10b
    a1 dw 0h12 
    a2 db 123456h  
    a3 db 1111_0011_1111_0000b
    _a4 dw 124h
    a5# db 33h 
    ?a6 dw 233h 
    a7~ db 1233h 
The characters from which a label can be constituted are the following:
    - letters, both a-z and A-Z
    - numbers 0-9
    - the characters _, $, #, @, !, . and ? 
Only letters, _ and ? are allowed as the first character of a tag.

    a0 db 10b -> ok
    a1 dw 0h12 -> not ok, h must be a suffix for the number to be valid 
    a2 db 123456h  -> ok, a2 will have the value 56h
    a3 db 1111_0011_1111_0000b -> ok, a3 will have the value 1111_0000b 
    _a4 dw 124h -> ok
    a5# db 33h  -> ok
    ?a6 dw 233h -> ok
    a7~ db 1233h -> ok
